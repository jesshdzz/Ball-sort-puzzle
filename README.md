Ball Sort Puzzle (Haskell + Python)Este es un proyecto universitario para la materia de Programaci√≥n Funcional, cuyo objetivo principal es demostrar una arquitectura de sistema h√≠brida donde Haskell act√∫a como el "cerebro" l√≥gico (backend) y Python act√∫a como la interfaz de usuario (frontend).El proyecto es una implementaci√≥n completa del popular juego "Ball Sort Puzzle", con un men√∫ de dificultad y un potente solver de IA capaz de resolver incluso los niveles m√°s dif√≠ciles.(Nota: Deber√°s reemplazar el enlace de arriba con un GIF que grabes de tu juego)‚ú® Caracter√≠sticasJuego Completo: L√≥gica de juego que sigue todas las reglas (movimiento, victoria, etc.).Movimiento en Bloque: Mueve autom√°ticamente todas las bolas del mismo color consecutivas que quepan en el tubo de destino.Interfaz Gr√°fica Din√°mica: Creada con Pygame, la interfaz es totalmente responsiva y se centra autom√°ticamente si se redimensiona la ventana.Men√∫ de Dificultad: Incluye 5 niveles (de F√°cil a Imposible) que ajustan el n√∫mero de colores y tubos.Animaciones Fluidas: Las bolas realizan un arco parab√≥lico suave al moverse entre tubos.¬°Solver de IA! Un potente solver capaz de encontrar la soluci√≥n para cualquier tablero.üèóÔ∏è Arquitectura del SistemaEste proyecto est√° dividido en dos componentes que se comunican en tiempo real:1. El Cerebro (Backend - Haskell)Es un ejecutable de l√≠nea de comandos (ball-sort-puzzle-exe) compilado con Stack.No tiene estado. Recibe el estado actual del juego en formato JSON.Procesa una acci√≥n ("mover", "resolver").Devuelve el nuevo estado del juego o la soluci√≥n en formato JSON.Contiene toda la l√≥gica del juego, reglas de movimiento y el algoritmo de la IA.2. La Interfaz (Frontend - Python)Es un script de Pygame (gui.py) que se ejecuta en un entorno virtual.No sabe las reglas del juego. Su √∫nico trabajo es "pintar" el estado que recibe.Cuando el usuario hace clic, empaqueta la intenci√≥n (ej. "mover de 3 a 5") y el estado actual en un JSON.Llama al ejecutable de Haskell usando subprocess y le pasa el JSON por stdin.Lee la respuesta de Haskell por stdout, la decodifica y actualiza la pantalla (o anima la soluci√≥n).üõ†Ô∏è Stack Tecnol√≥gicoBackend (L√≥gica Central)HaskellStack: Para la gesti√≥n de dependencias y compilaci√≥n.aeson: Para la serializaci√≥n/deserializaci√≥n de JSON.containers (Set): Para la optimizaci√≥n de estados visitados en el solver.Frontend (Interfaz de Usuario)Python 3pygame: Para la creaci√≥n de la ventana, gr√°ficos, animaciones y manejo de eventos.venv: Para la gesti√≥n de un entorno aislado.üöÄ C√≥mo EjecutarloEl proyecto requiere compilar el backend de Haskell primero, y luego ejecutar el frontend de Python.Paso 1: Compilar el Backend (Haskell)Aseg√∫rate de tener Stack instalado.Bash# 1. Navega a la ra√≠z del proyecto
# (Donde est√° el archivo stack.yaml)

# 2. Compila el proyecto y sus dependencias
stack build

# 3. Instala el ejecutable en la ra√≠z del proyecto
# (Esto crea el archivo 'ball-sort-puzzle-exe')
stack install --local-bin-path .
Paso 2: Ejecutar el Frontend (Python)Aseg√∫rate de tener python3 y pip instalados.Bash# 1. (Opcional pero recomendado) Crea y activa un entorno virtual
python3 -m venv venv
source venv/bin/activate  # (En Windows: .\venv\Scripts\activate)

# 2. Instala la √∫nica dependencia (pygame)
pip install pygame

# 3. Ejecuta el juego
python gui.py
üß† El Solver IA: De "Fuerza Bruta" a "Inteligencia"Un requisito clave era crear un solver que funcionara en niveles dif√≠ciles. Un simple BFS (B√∫squeda en Amplitud) fallar√≠a al explorar miles de millones de estados in√∫tiles.La soluci√≥n implementada es un Greedy Best-First Search (B√∫squeda "Codiciosa").1. La Heur√≠stica (La "Intuici√≥n")Para que el solver sea "inteligente", le dimos una "funci√≥n heur√≠stica" que le permite "puntuar" qu√© tan "ordenado" est√° un tablero. La puntuaci√≥n se calcula as√≠:Puntuaci√≥n = Total de bolas que no coinciden con el color de la bola del fondo de su tubo.Un tubo [Rojo, Rojo, Rojo] (fondo: Rojo) tiene una puntuaci√≥n de 0.Un tubo [Verde, Azul, Rojo, Rojo] (fondo: Rojo) tiene una puntuaci√≥n de 2 (Verde y Azul est√°n "mal").El algoritmo siempre da prioridad a explorar el movimiento que resulta en el tablero con la puntuaci√≥n m√°s baja.2. Optimizaci√≥n (Evitar Bucles)Para evitar que la IA se quede atascada en bucles (ej. A->B, B->A), utilizamos dos t√©cnicas:Normalizaci√≥n de Estados: Antes de guardar un estado como "visitado", lo "normalizamos" usando sort. Esto le ense√±a a la IA que un tablero con [TuboA, TuboB] es id√©ntico a [TuboB, TuboA], reduciendo dr√°sticamente el n√∫mero de estados a explorar.Data.Set: Usamos un Set (Conjunto) de Haskell en lugar de una lista para guardar los estados visitados. Comprobar si un estado existe en un Set es casi instant√°neo ($O(\log n)$), mientras que en una lista es extremadamente lento ($O(n)$).Esta combinaci√≥n de Heur√≠stica + Normalizaci√≥n + Set es lo que permite al solver encontrar soluciones a niveles "Imposibles" en segundos, en lugar de a√±os.
